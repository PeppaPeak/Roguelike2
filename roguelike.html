<!DOCTYPE html>
<html>
<head>
<title>Roguelike</title>
<style>
    body { margin: 0; overflow: hidden; background: white; }
    canvas { display: block; margin: 0 auto; background: white; border: 6px solid black; }
    #cardContainer {
        position: absolute;
        top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        display: none;
        gap: 20px;
    }
    .card {
        width: 200px; height: 260px;
        border: 4px solid black;
        background: #e0e0e0;
        padding: 10px;
        text-align: center;
        cursor: pointer;
        font-family: Arial;
    }
</style>
</head>
<body>

<canvas id="gameCanvas"></canvas>
<div id="cardContainer"></div>

<script>
// ===============================
// CANVAS SETUP
// ===============================
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
canvas.width = 900;
canvas.height = 700;

// ===============================
// PLAYER
// ===============================
let player = {
    x: canvas.width/2,
    y: canvas.height/2,
    size: 20,
    speed: 3,
    hp: 100,
    maxHp: 100,
    xp: 0,
    level: 1
};

// ===============================
// INPUT
// ===============================
let keys = {};
document.addEventListener("keydown", e => keys[e.key] = true);
document.addEventListener("keyup", e => keys[e.key] = false);

// ===============================
// ENEMIES
// ===============================
let enemies = [];
let wave = 1;

function spawnEnemies() {
    let count = 5 + wave * 3;

    for (let i = 0; i < count; i++) {
        let type = "circle";

        if (wave >= 3) {
            let r = Math.random();
            if (r < 0.3) type = "square";
            else if (r < 0.6) type = "triangle";
        }

        enemies.push(makeEnemy(type));
    }
}

function makeEnemy(type) {
    let hp, speed, size, damage, color;

    if (type === "circle") {
        hp = 8 + wave;
        speed = 1.2;
        size = 18;
        damage = 10;
        color = "red";
    }
    if (type === "square") {
        hp = 22 + wave*2;
        speed = 0.6;
        size = 25;
        damage = 15;
        color = "#cc0000";
    }
    if (type === "triangle") {
        hp = 5;
        speed = 2.4;
        size = 16;
        damage = 5;
        color = "#ff4444";
    }

    let angle = Math.random() * Math.PI * 2;
    return {
        x: player.x + Math.cos(angle)*500,
        y: player.y + Math.sin(angle)*500,
        hp, maxHp: hp,
        speed, size, damage,
        type, color
    };
}

// ===============================
// WEAPONS
// ===============================
let weapons = {
    rotatingOrb: {
        unlocked: true,
        damage: 2,
        speed: 0.04,
        count: 1,
        angle: 0
    },
    shooter: { unlocked: true, damage: 3, rate: 30, cooldown: 0 },
    flameAura: { unlocked: true, damage: 0.5, radius: 80 },
    daggerBurst: { unlocked: true, damage: 5, rate: 70, cooldown: 0 },
};
let projectiles = [];

// ===============================
// COMBAT
// ===============================
function updateOrbWeapon() {
    let w = weapons.rotatingOrb;
    w.angle += w.speed;

    for (let i = 0; i < w.count; i++) {
        let angle = w.angle + (i * Math.PI * 2 / w.count);
        let ox = player.x + Math.cos(angle)*60;
        let oy = player.y + Math.sin(angle)*60;

        enemies.forEach(e => {
            if (Math.hypot(ox - e.x, oy - e.y) < e.size + 5) {
                e.hp -= w.damage * 0.4;
            }
        });

        ctx.fillStyle = "cyan";
        ctx.beginPath();
        ctx.arc(ox, oy, 6, 0, Math.PI*2);
        ctx.fill();
    }
}

function updateShooter() {
    let w = weapons.shooter;
    if (!w.unlocked) return;

    if (w.cooldown > 0) w.cooldown--;
    else {
        w.cooldown = w.rate;

        if (enemies.length > 0) {
            let target = enemies[0];
            projectiles.push({
                x: player.x,
                y: player.y,
                vx: (target.x - player.x)/20,
                vy: (target.y - player.y)/20,
                damage: w.damage
            });
        }
    }
}

function updateDaggers() {
    let w = weapons.daggerBurst;
    if (!w.unlocked) return;

    if (w.cooldown > 0) w.cooldown--;
    else {
        w.cooldown = w.rate;

        for (let i = 0; i < 8; i++) {
            let angle = i * (Math.PI/4);
            projectiles.push({
                x: player.x,
                y: player.y,
                vx: Math.cos(angle)*6,
                vy: Math.sin(angle)*6,
                damage: w.damage
            });
        }
    }
}

function updateProjectiles() {
    projectiles.forEach(p => {
        p.x += p.vx;
        p.y += p.vy;

        enemies.forEach(e => {
            if (Math.hypot(p.x - e.x, p.y - e.y) < e.size) {
                e.hp -= p.damage;
                p.dead = true;
            }
        });
    });

    projectiles = projectiles.filter(p => !p.dead);
}

// ===============================
// UPDATE
// ===============================
function update() {

    // Movement
    if (keys["w"]) player.y -= player.speed;
    if (keys["s"]) player.y += player.speed;
    if (keys["a"]) player.x -= player.speed;
    if (keys["d"]) player.x += player.speed;

    // Map boundaries
    player.x = Math.max(20, Math.min(canvas.width - 20, player.x));
    player.y = Math.max(20, Math.min(canvas.height - 20, player.y));

    // Enemies
    enemies.forEach(e => {
        let angle = Math.atan2(player.y - e.y, player.x - e.x);
        e.x += Math.cos(angle) * e.speed;
        e.y += Math.sin(angle) * e.speed;
    });

    updateOrbWeapon();
    updateShooter();
    updateDaggers();
    updateProjectiles();

    enemies = enemies.filter(e => e.hp > 0);

    if (enemies.length === 0) {
        wave++;
        spawnEnemies();
    }
}

// ===============================
// DRAWING
// ===============================
function draw() {
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // Player
    ctx.fillStyle = "blue";
    ctx.beginPath();
    ctx.arc(player.x, player.y, player.size, 0, Math.PI*2);
    ctx.fill();

    // Enemies
    enemies.forEach(e => {
        ctx.strokeStyle = "black";
        ctx.lineWidth = 3;

        ctx.fillStyle = e.color;

        if (e.type === "circle") {
            ctx.beginPath();
            ctx.arc(e.x, e.y, e.size, 0, Math.PI*2);
            ctx.fill(); ctx.stroke();
        }

        if (e.type === "square") {
            ctx.fillRect(e.x - e.size, e.y - e.size, e.size*2, e.size*2);
            ctx.strokeRect(e.x -
