<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Roguelike</title>
<style>
    body { margin:0; overflow:hidden; background:#111; }
    canvas { background:#111; display:block; margin:0 auto; }
</style>
</head>
<body>
<canvas id="game"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
canvas.width = 900;
canvas.height = 600;

// WORLD BORDER
const BORDER = { x:50, y:50, w:800, h:500 };

// PLAYER
const player = {
    x: 450,
    y: 300,
    size: 20,
    speed: 3,
    hp: 100,
    maxHp: 100,
    damage: 10,
    vx: 0,
    vy: 0
};

// WEAPONS
let weapons = [];
function spawnWeapons() {
    weapons = [];
    for (let i = 0; i < 12; i++) {
        weapons.push({
            angle: (Math.PI * 2 / 12) * i,
            radius: 60,
            size: 12,
            speed: 0.05 + Math.random()*0.05
        });
    }
}
spawnWeapons();

// ENEMIES
let enemies = [];

function spawnEnemy(type) {
    let enemy = {
        type: type,
        x: Math.random() * (BORDER.w - 40) + BORDER.x + 20,
        y: Math.random() * (BORDER.h - 40) + BORDER.y + 20,
        vx: 0,
        vy: 0,
        size: type === "triangle" ? 18 : 25,
        color: type === "triangle" ? "#ff5f5f" :
               type === "square"   ? "#5fb0ff" : "#90ff6c",
        hp: type === "triangle" ? 20 :
            type === "square"   ? 90 : 45,
        maxHp: type === "triangle" ? 20 :
               type === "square"   ? 90 : 45,
        speed: type === "triangle" ? 3.5 :
               type === "square"   ? 1.3 : 2,
        damage: type === "triangle" ? 5 :
                 type === "square"   ? 15 : 10
    };
    enemies.push(enemy);
}

// WAVES
let wave = 1;
let waveTimer = 0;

// UTIL
function dist(a,b,c,d){ return Math.hypot(a-c,b-d); }

// FIX ENEMIES GETTING STUCK
function separate(a, b) {
    const d = dist(a.x, a.y, b.x, b.y);
    const overlap = a.size + b.size - d;
    if (overlap > 0) {
        let nx = (a.x - b.x) / d;
        let ny = (a.y - b.y) / d;
        a.x += nx * overlap * 0.5;
        a.y += ny * overlap * 0.5;
        b.x -= nx * overlap * 0.5;
        b.y -= ny * overlap * 0.5;
    }
}

// GAME LOOP
function update() {

    // PLAYER MOVEMENT
    player.x += player.vx;
    player.y += player.vy;

    // CONSTRAIN PLAYER
    player.x = Math.max(BORDER.x + player.size, Math.min(BORDER.x+BORDER.w-player.size, player.x));
    player.y = Math.max(BORDER.y + player.size, Math.min(BORDER.y+BORDER.h-player.size, player.y));

    // WEAPON ORBIT
    weapons.forEach(w => {
        w.angle += w.speed;
    });

    // WAVE SYSTEM
    waveTimer--;
    if (waveTimer <= 0) {
        for (let i = 0; i < wave * 2; i++) spawnEnemy("normal");
        if (wave >= 2) spawnEnemy("square");
        if (wave >= 3) spawnEnemy("triangle");
        wave++;
        waveTimer = 600;
    }

    // ENEMY MOVEMENT & FIXED DAMAGE SYSTEM
    enemies.forEach(e => {
        let angle = Math.atan2(player.y - e.y, player.x - e.x);
        e.vx = Math.cos(angle) * e.speed;
        e.vy = Math.sin(angle) * e.speed;
        e.x += e.vx;
        e.y += e.vy;

        // ---- FIXED DAMAGE LOGIC ----
        const d = dist(e.x, e.y, player.x, player.y);
        const hitRange = e.size + player.size - 4; // ← 4px safety buffer (fixes random damage)

        if (d < hitRange) {
            // Deal damage (smooth)
            player.hp -= e.damage * 0.02;

            // Push enemy back cleanly
            let nx = (e.x - player.x) / d;
            let ny = (e.y - player.y) / d;
            e.x += nx * 3;
            e.y += ny * 3;

        } else if (d < e.size + player.size) {
            // Close but NOT touching → push back with NO damage
            let nx = (e.x - player.x) / d;
            let ny = (e.y - player.y) / d;
            e.x += nx * 1.5;
            e.y += ny * 1.5;
        }
        // ---------------------------------
    });

    // FIX ENEMIES COLLIDING INSIDE EACH OTHER
    for (let i = 0; i < enemies.length; i++) {
        for (let j = i+1; j < enemies.length; j++) {
            separate(enemies[i], enemies[j]);
        }
    }

    // WEAPON COLLISIONS
    enemies.forEach((e, ei) => {
        weapons.forEach(w => {
            let wx = player.x + Math.cos(w.angle)*w.radius;
            let wy = player.y + Math.sin(w.angle)*w.radius;
            if (dist(wx, wy, e.x, e.y) < e.size + w.size) {
                e.hp -= player.damage;
                if (e.hp <= 0) enemies.splice(ei,1);
            }
        });
    });
}

function draw() {
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // BORDER
    ctx.strokeStyle = "#444";
    ctx.lineWidth = 4;
    ctx.strokeRect(BORDER.x, BORDER.y, BORDER.w, BORDER.h);

    // PLAYER
    ctx.fillStyle = "#fff";
    ctx.beginPath();
    ctx.arc(player.x, player.y, player.size, 0, Math.PI*2);
    ctx.fill();

    // WEAPONS
    weapons.forEach(w=>{
        let wx = player.x + Math.cos(w.angle)*w.radius;
        let wy = player.y + Math.sin(w.angle)*w.radius;
        ctx.fillStyle = "#ffd966";
        ctx.beginPath();
        ctx.arc(wx, wy, w.size, 0, Math.PI*2);
        ctx.fill();
    });

    // ENEMIES + HP BARS
    enemies.forEach(e=>{
        ctx.fillStyle = e.color;

        if (e.type === "triangle") {
            ctx.beginPath();
            ctx.moveTo(e.x, e.y - e.size);
            ctx.lineTo(e.x - e.size, e.y + e.size);
            ctx.lineTo(e.x + e.size, e.y + e.size);
            ctx.closePath();
            ctx.fill();
        } else {
            ctx.fillRect(e.x - e.size, e.y - e.size, e.size*2, e.size*2);
        }

        // lighter HP bar
        let light = e.color + "88";
        let barW = (e.hp / e.maxHp) * e.size*2;

        ctx.fillStyle = light;
        ctx.fillRect(e.x - e.size, e.y - e.size - 8, barW, 5);
    });

    // PLAYER HP BAR
    ctx.fillStyle = "#ff4444";
    ctx.fillRect(20, 20, 200*(player.hp/player.maxHp), 20);
    ctx.strokeStyle = "#fff";
    ctx.strokeRect(20,20,200,20);
}

function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
}
loop();

// INPUT
document.addEventListener("keydown", e=>{
    if (e.key==="w") player.vy = -player.speed;
    if (e.key==="s") player.vy =  player.speed;
    if (e.key==="a") player.vx = -player.speed;
    if (e.key==="d") player.vx =  player.speed;
});
document.addEventListener("keyup", e=>{
    if (e.key==="w"||e.key==="s") player.vy = 0;
    if (e.key==="a"||e.key==="d") player.vx = 0;
});
</script>
</body>
</html>
