<!DOCTYPE html>
<html>
<head>
<title>Roguelike</title>
<meta charset="UTF-8">
<style>
    body { margin:0; background:#fff; overflow:hidden; }
    canvas { background:white; display:block; margin:0 auto; }
</style>
</head>
<body>
<canvas id="game" width="900" height="600"></canvas>

<script>
// ---------------------------------------------------
// CANVAS
// ---------------------------------------------------
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

const W = canvas.width;
const H = canvas.height;

// ---------------------------------------------------
// PLAYER
// ---------------------------------------------------
const player = {
    x: W/2,
    y: H/2,
    size: 15,
    speed: 3,
    hp: 100,
    maxHp: 100,
    xp: 0,
    level: 1,
    xpNeeded: 30
};

let keys = {};
document.addEventListener("keydown", e => keys[e.key] = true);
document.addEventListener("keyup",   e => keys[e.key] = false);

// ---------------------------------------------------
// ENEMIES
// All enemies share same base structure
// ---------------------------------------------------
let enemies = [];
let wave = 1;
let spawnTimer = 0;

// SPAWN ENEMY TYPES
function spawnEnemy() {
    const typeList = [
        "circle",      // basic red
        "square",      // tanky slow
        "triangle",    // fast weak
        "tank",
        "speedster",
        "healer",
        "attacker"
    ];

    let type = typeList[Math.floor(Math.random() * Math.min(typeList.length, 2 + Math.floor(wave/2)))];

    let x = Math.random()*W;
    let y = Math.random()*H;

    if (Math.random() < 0.5) x = Math.random() < 0.5 ? -20 : W+20;
    else y = Math.random() < 0.5 ? -20 : H+20;

    enemies.push(createEnemyType(type, x, y));
}

function createEnemyType(type, x, y) {
    switch(type) {
        case "circle":
            return enemyTemplate(x,y, 20, 1.5, 10, "circle","red");

        case "square":
            return enemyTemplate(x,y, 50, 0.8, 12, "square","darkred");

        case "triangle":
            return enemyTemplate(x,y, 12, 2.5, 6, "triangle","red");

        case "tank":
            return enemyTemplate(x,y, 120, 0.7, 15, "circle","maroon");

        case "speedster":
            return enemyTemplate(x,y, 10, 3.5, 5, "triangle","orange");

        case "healer":
            return enemyTemplate(x,y, 40, 1.0, 5, "circle","green", true);

        case "attacker":
            return enemyTemplate(x,y, 25, 1.2, 25, "circle","black");
    }
}

function enemyTemplate(x,y,hp,spd,dmg,shape,color,healer=false) {
    return {
        x, y,
        hp,
        speed: spd,
        dmg,
        size: 14,
        shape,
        color,
        healer,
        healCooldown: 0
    };
}

// ---------------------------------------------------
// WEAPONS
// ---------------------------------------------------
let weapons = [];
let addons = [];

// ROTATING ORB
weapons.push({
    name:"Rotating Orb",
    level:1,
    orbs:1,
    dmg:2,
    speed:0.05,
    angle:0
});

// Add many other weapons
const weaponLibrary = {
    "Rocket Launcher": {
        create() { return {name:"Rocket Launcher", level:1, cooldown:0, cdMax:40, dmg:20}; }
    },
    "Knockback Square": {
        create() { return {name:"Knockback Square", level:1, size:40, dmg:5}; }
    },
    "Frost Shot": {
        create() { return {name:"Frost Shot", level:1, cooldown:0, cdMax:30, dmg:6, slow:0.4}; }
    }
};

// ADD-ONS (Fire Orb, Scatter Ring, Lightning Bolt)
const addonLibrary = {
    "Fire Orb": {
        apply() { addons.push({type:"fire", dmg:1}); }
    },
    "Scatter Ring": {
        apply() { addons.push({type:"scatter", count:8, dmg:2}); }
    },
    "Lightning Bolt": {
        apply() { addons.push({type:"lightning", dmg:15}); }
    }
};

// ---------------------------------------------------
// PROJECTILES
// ---------------------------------------------------
let projectiles = [];

// ---------------------------------------------------
// GAME LOOP
// ---------------------------------------------------
function update() {
    movePlayer();
    updateWeapons();
    updateEnemies();
    updateProjectiles();
    render();
    requestAnimationFrame(update);
}

// ---------------------------------------------------
// PLAYER MOVEMENT
// ---------------------------------------------------
function movePlayer() {
    if (keys["w"]) player.y -= player.speed;
    if (keys["s"]) player.y += player.speed;
    if (keys["a"]) player.x -= player.speed;
    if (keys["d"]) player.x += player.speed;

    player.x = Math.max(0, Math.min(W, player.x));
    player.y = Math.max(0, Math.min(H, player.y));
}

// ---------------------------------------------------
// WEAPON BEHAVIOR
// ---------------------------------------------------
function updateWeapons() {
    for (let w of weapons) {
        if (w.name === "Rotating Orb") {
            w.angle += w.speed;
        }

        if (w.name === "Rocket Launcher") {
            w.cooldown--;
            if (w.cooldown <= 0) {
                w.cooldown = w.cdMax;
                if (enemies.length > 0) {
                    let e = enemies[Math.floor(Math.random()*enemies.length)];
                    projectiles.push({
                        x:player.x,
                        y:player.y,
                        tx:e.x,
                        ty:e.y,
                        speed:3,
                        dmg:w.dmg,
                        type:"rocket"
                    });
                }
            }
        }

        if (w.name === "Frost Shot") {
            w.cooldown--;
            if (w.cooldown <= 0) {
                w.cooldown = w.cdMax;
                projectiles.push({
                    x:player.x,
                    y:player.y,
                    angle:Math.random()*Math.PI*2,
                    speed:4,
                    dmg:w.dmg,
                    slow:w.slow,
                    type:"frost"
                });
            }
        }
    }
}

// ---------------------------------------------------
// PROJECTILES UPDATE
// ---------------------------------------------------
function updateProjectiles() {
    for (let i=projectiles.length-1;i>=0;i--) {
        let p = projectiles[i];

        if (p.type === "rocket") {
            let ang = Math.atan2(p.ty - p.y, p.tx - p.x);
            p.x += Math.cos(ang)*p.speed;
            p.y += Math.sin(ang)*p.speed;
        }

        if (p.type === "frost") {
            p.x += Math.cos(p.angle)*p.speed;
            p.y += Math.sin(p.angle)*p.speed;
        }

        for (let j=enemies.length-1;j>=0;j--) {
            let e = enemies[j];
            let dx = e.x - p.x;
            let dy = e.y - p.y;
            if (dx*dx + dy*dy < 20*20) {

                e.hp -= p.dmg;

                if (p.type === "frost") e.speed *= p.slow;

                projectiles.splice(i,1);
                break;
            }
        }
    }
}

// ---------------------------------------------------
// ENEMY UPDATE
// ---------------------------------------------------
function updateEnemies() {
    spawnTimer++;
    if (spawnTimer > 60 - Math.min(40, wave*2)) {
        spawnTimer = 0;
        spawnEnemy();
    }

    if (Math.random() < 0.002) wave++;

    for (let i=enemies.length-1;i>=0;i--) {
        let e = enemies[i];

        // healer ability
        if (e.healer) {
            e.healCooldown--;
            if (e.healCooldown <= 0) {
                e.healCooldown = 120;
                for (let h of enemies) {
                    if (h !== e && Math.hypot(h.x-e.x, h.y-e.y) < 120)
                        h.hp += 4;
                }
            }
        }

        // move towards player
        let ang = Math.atan2(player.y - e.y, player.x - e.x);
        e.x += Math.cos(ang)*e.speed;
        e.y += Math.sin(ang)*e.speed;

        // collision with player
        if (Math.hypot(e.x-player.x, e.y-player.y) < e.size + player.size) {
            player.hp -= e.dmg * 0.02;
        }

        // enemy death
        if (e.hp <= 0) {
            enemies.splice(i,1);
            gainXP(5);
        }
    }
}

// ---------------------------------------------------
// XP + LEVEL
// ---------------------------------------------------
function gainXP(amount) {
    player.xp += amount;
    if (player.xp >= player.xpNeeded) {
        player.xp -= player.xpNeeded;
        player.level++;
        player.xpNeeded += 10;
        giveUpgradeChoices();
    }
}

// ---------------------------------------------------
// UPGRADE SYSTEM
// ---------------------------------------------------
function giveUpgradeChoices() {
    // Very simple alert-based selection
    let choices = [
        "Rotating Orb Upgrade",
        "Rocket Launcher",
        "Knockback Square",
        "Frost Shot",
        "Fire Orb",
        "Scatter Ring",
        "Lightning Bolt"
    ];

    let pick = prompt("Choose upgrade:\n" + choices.join("\n"));

    if (pick === "Rotating Orb Upgrade") {
        let orb = weapons.find(w=>w.name==="Rotating Orb");
        orb.orbs++;
        orb.dmg += 1;
    }

    if (weaponLibrary[pick]) {
        weapons.push(weaponLibrary[pick].create());
    }

    if (addonLibrary[pick]) {
        addonLibrary[pick].apply();
    }
}

// ---------------------------------------------------
// RENDERING
// ---------------------------------------------------
function render() {
    ctx.fillStyle = "white";
    ctx.fillRect(0,0,W,H);

    // player
    ctx.fillStyle = "blue";
    ctx.beginPath();
    ctx.arc(player.x, player.y, player.size, 0, Math.PI*2);
    ctx.fill();

    // rotating orb draw
    for (let w of weapons) {
        if (w.name === "Rotating Orb") {
            for (let i=0;i<w.orbs;i++) {
                let a = w.angle + (Math.PI*2)*(i/w.orbs);
                let ox = player.x + Math.cos(a)*60;
                let oy = player.y + Math.sin(a)*60;

                ctx.fillStyle = "purple";
                ctx.beginPath();
                ctx.arc(ox, oy, 8, 0, Math.PI*2);
                ctx.fill();

                // orb damage
                for (let e of enemies) {
                    if (Math.hypot(e.x-ox, e.y-oy) < e.size+8)
                        e.hp -= w.dmg*0.1;
                }
            }
        }
    }

    // projectiles
    ctx.fillStyle = "black";
    for (let p of projectiles) {
        ctx.beginPath();
        ctx.arc(p.x, p.y, 5, 0, Math.PI*2);
        ctx.fill();
    }

    // enemies
    for (let e of enemies) {
        ctx.fillStyle = e.color;

        if (e.shape === "circle") {
            ctx.beginPath();
            ctx.arc(e.x, e.y, e.size, 0, Math.PI*2);
            ctx.fill();
        }

        if (e.shape === "square") {
            ctx.fillRect(e.x-e.size, e.y-e.size, e.size*2, e.size*2);
        }

        if (e.shape === "triangle") {
            ctx.beginPath();
            ctx.moveTo(e.x, e.y-e.size);
            ctx.lineTo(e.x-e.size, e.y+e.size);
            ctx.lineTo(e.x+e.size, e.y+e.size);
            ctx.closePath();
            ctx.fill();
        }
    }

    // UI
    ctx.fillStyle = "black";
    ctx.fillText("HP: " + Math.floor(player.hp), 20,20);
    ctx.fillText("XP: " + player.xp + "/" + player.xpNeeded, 20,40);
    ctx.fillText("Wave: " + wave, 20,60);
}

// ---------------------------------------------------
update();
</script>
</body>
</html>
