<!DOCTYPE html>
<html>
<head>
<title>Roguelike</title>
<style>
    body { margin: 0; overflow: hidden; background: white; }
    canvas { display: block; margin: 0 auto; background: white; }
    #cardContainer {
        position: absolute;
        top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        display: none;
        gap: 20px;
    }
    .card {
        width: 200px; height: 260px;
        border: 4px solid black;
        background: #e0e0e0;
        padding: 10px;
        text-align: center;
        cursor: pointer;
        font-family: Arial;
    }
</style>
</head>
<body>

<canvas id="gameCanvas"></canvas>

<div id="cardContainer"></div>

<script>
// ===============================
// CANVAS SETUP
// ===============================
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
canvas.width = 900;
canvas.height = 700;

// ===============================
// PLAYER
// ===============================
let player = {
    x: canvas.width/2,
    y: canvas.height/2,
    size: 20,
    speed: 3,
    hp: 100,
    maxHp: 100,
    xp: 0,
    level: 1
};

// ===============================
// INPUT
// ===============================
let keys = {};
document.addEventListener("keydown", e => keys[e.key] = true);
document.addEventListener("keyup", e => keys[e.key] = false);

// ===============================
// ENEMIES
// ===============================
let enemies = [];
let wave = 1;

function spawnEnemies() {
    let count = 5 + wave * 3;

    for (let i = 0; i < count; i++) {
        let type = "circle";

        // After wave 3 include new enemy types
        if (wave >= 3) {
            let r = Math.random();
            if (r < 0.3) type = "square";
            else if (r < 0.6) type = "triangle";
        }

        enemies.push(makeEnemy(type));
    }
}

function makeEnemy(type) {
    let hp, speed, size, damage;

    if (type === "circle") {
        hp = 8 + wave;
        speed = 1.2;
        size = 18;
        damage = 10;
    }
    if (type === "square") {
        hp = 20 + wave*2;
        speed = 0.6;
        size = 25;
        damage = 15;
    }
    if (type === "triangle") {
        hp = 5;
        speed = 2.2;
        size = 16;
        damage = 5;
    }

    let angle = Math.random() * Math.PI * 2;
    return {
        x: player.x + Math.cos(angle)*500,
        y: player.y + Math.sin(angle)*500,
        hp, maxHp: hp,
        speed, size, damage,
        type
    };
}

// ===============================
// WEAPONS
// ===============================
let weapons = {
    rotatingOrb: {
        unlocked: true,
        damage: 2,
        speed: 0.04,
        count: 1,
        angle: 0
    },
    // tons of extra weapons added:
    shooter: { unlocked: false, damage: 3, rate: 60, cooldown: 0 },
    flameAura: { unlocked: false, damage: 0.5, radius: 80 },
    daggerBurst: { unlocked: false, damage: 5, rate: 70, cooldown: 0 },
};
let projectiles = [];

// ===============================
// CARD UPGRADES
// ===============================
const allCards = [
    { name: "More Orb Damage", apply: () => weapons.rotatingOrb.damage++ },
    { name: "More Orbs", apply: () => weapons.rotatingOrb.count++ },
    { name: "Faster Orb", apply: () => weapons.rotatingOrb.speed += 0.01 },
    { name: "Unlock Shooter", apply: () => weapons.shooter.unlocked = true },
    { name: "Shooter Damage", apply: () => weapons.shooter.damage++ },
    { name: "Unlock Flame Aura", apply: () => weapons.flameAura.unlocked = true },
    { name: "Aura Damage", apply: () => weapons.flameAura.damage += 0.3 },
    { name: "Unlock Daggers", apply: () => weapons.daggerBurst.unlocked = true },
    { name: "Dagger Damage", apply: () => weapons.daggerBurst.damage++, },
];

// ===============================
// GAME LOOP
// ===============================
function update() {

    // ---- Movement ----
    if (keys["w"]) player.y -= player.speed;
    if (keys["s"]) player.y += player.speed;
    if (keys["a"]) player.x -= player.speed;
    if (keys["d"]) player.x += player.speed;

    // ---- Enemies ----
    enemies.forEach(e => {
        let angle = Math.atan2(player.y - e.y, player.x - e.x);
        e.x += Math.cos(angle) * e.speed;
        e.y += Math.sin(angle) * e.speed;

        // Collision dmg
        if (dist(player, e) < player.size + e.size) {
            player.hp -= e.damage * 0.05;
        }
    });

    // ---- Weapons ----
    updateOrbWeapon();
    updateShooter();
    updateDaggers();
    updateProjectiles();

    // ---- Kill / XP ----
    enemies = enemies.filter(e => {
        if (e.hp <= 0) {
            player.xp += 10;
            return false;
        }
        return true;
    });

    // ---- Level Up ----
    if (player.xp >= player.level * 50) {
        player.level++;
        showCards();
    }

    // ---- New Wave ----
    if (enemies.length === 0) {
        wave++;
        spawnEnemies();
    }
}

function dist(a, b) {
    return Math.hypot(a.x - b.x, a.y - b.y);
}

// ===============================
// WEAPON FUNCTIONS
// ===============================

// --- Rotating Orb ---
function updateOrbWeapon() {
    let w = weapons.rotatingOrb;
    w.angle += w.speed;

    for (let i = 0; i < w.count; i++) {
        let angle = w.angle + (i * Math.PI * 2 / w.count);
        let ox = player.x + Math.cos(angle)*60;
        let oy = player.y + Math.sin(angle)*60;

        enemies.forEach(e => {
            if (Math.hypot(ox - e.x, oy - e.y) < e.size + 5) {
                e.hp -= w.damage * 0.2;
            }
        });

        // Draw orb
        ctx.fillStyle = "blue";
        ctx.beginPath();
        ctx.arc(ox, oy, 6, 0, Math.PI*2);
        ctx.fill();
    }
}

// --- Shooter (fires bullets) ---
function updateShooter() {
    let w = weapons.shooter;
    if (!w.unlocked) return;

    if (w.cooldown > 0) w.cooldown--;
    else {
        w.cooldown = w.rate;

        // Shoot nearest enemy
        if (enemies.length > 0) {
            let target = enemies[0];
            projectiles.push({
                x: player.x,
                y: player.y,
                vx: (target.x - player.x)/20,
                vy: (target.y - player.y)/20,
                damage: w.damage
            });
        }
    }
}

// --- Daggers ---
function updateDaggers() {
    let w = weapons.daggerBurst;
    if (!w.unlocked) return;

    if (w.cooldown > 0) w.cooldown--;
    else {
        w.cooldown = w.rate;

        for (let i = 0; i < 8; i++) {
            let angle = i * (Math.PI/4);
            projectiles.push({
                x: player.x,
                y: player.y,
                vx: Math.cos(angle)*6,
                vy: Math.sin(angle)*6,
                damage: w.damage
            });
        }
    }
}

function updateProjectiles() {
    projectiles.forEach(p => {
        p.x += p.vx;
        p.y += p.vy;

        enemies.forEach(e => {
            if (dist(e, p) < e.size) {
                e.hp -= p.damage;
                p.dead = true;
            }
        });
    });

    projectiles = projectiles.filter(p => !p.dead);
}

// ===============================
// CARDS (UPGRADES)
// ===============================
function showCards() {
    let container = document.getElementById("cardContainer");
    container.innerHTML = "";
    container.style.display = "flex";

    let picks = [];
    while (picks.length < 3) {
        let c = allCards[Math.floor(Math.random()*allCards.length)];
        if (!picks.includes(c)) picks.push(c);
    }

    picks.forEach(card => {
        let div = document.createElement("div");
        div.className = "card";
        div.innerHTML = `<h3>${card.name}</h3>`;
        div.onclick = () => {
            card.apply();
            container.style.display = "none";
        };
        container.appendChild(div);
    });
}

// ===============================
// DRAWING
// ===============================
function draw() {
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // Player
    ctx.fillStyle = "blue";
    ctx.beginPath();
    ctx.arc(player.x, player.y, player.size, 0, Math.PI*2);
    ctx.fill();

    // Enemies
    enemies.forEach(e => {
        ctx.strokeStyle = "black";
        ctx.lineWidth = 3;

        if (e.type === "circle") {
            ctx.fillStyle = "red";
            ctx.beginPath();
            ctx.arc(e.x, e.y, e.size, 0, Math.PI*2);
            ctx.fill();
            ctx.stroke();
        }

        if (e.type === "square") {
            ctx.fillStyle = "red";
            ctx.fillRect(e.x - e.size, e.y - e.size, e.size*2, e.size*2);
            ctx.strokeRect(e.x - e.size, e.y - e.size, e.size*2, e.size*2);
        }

        if (e.type === "triangle") {
            ctx.fillStyle = "red";
            ctx.beginPath();
            ctx.moveTo(e.x, e.y - e.size);
            ctx.lineTo(e.x - e.size, e.y + e.size);
            ctx.lineTo(e.x + e.size, e.y + e.size);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        }

        // ---- HEALTH BAR ----
        ctx.fillStyle = "black";
        ctx.fillRect(e.x - e.size, e.y - e.size - 10, e.size*2, 6);
        ctx.fillStyle = "lime";
        ctx.fillRect(e.x - e.size, e.y - e.size - 10, (e.hp/e.maxHp) * (e.size*2), 6);
    });

    // Projectiles
    ctx.fillStyle = "black";
    projectiles.forEach(p => {
        ctx.fillRect(p.x-3, p.y-3, 6, 6);
    });
}

function gameLoop() {
    update();
    draw();
    requestAnimationFrame(gameLoop);
}

spawnEnemies();
gameLoop();
</script>

</body>
</html>
